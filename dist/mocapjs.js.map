{"version":3,"sources":["webpack:///webpack/bootstrap 523a35f924ba6ca7bbf7","webpack:///./lib/MocapJS.js","webpack:///./lib/bvhCharacter.js","webpack:///./lib/parsers.js","webpack:///./lib/bvhParser.js","webpack:///./lib/bvhStreamParser.js","webpack:///./lib/c3dCharacter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA,uC;;;;;;ACFA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAmB,sBAAsB;AACzC;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA,0D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA,wF;AACA;AACA,wF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,4D;AACA,+C;AACA,qBAAoB;AACpB,8C;AACA;;AAEA,4D;AACA,+C;AACA,qBAAoB;AACpB,8C;AACA;;AAEA,4D;AACA,+C;AACA,qBAAoB;AACpB,8C;AACA;;;;AAIA;;AAEA,6E;;AAEA;AACA;;AAEA,qD;AACA,gD;AACA;AACA,UAAS,E;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4E;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;;AAEA,4DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;;AAEA,iBAAgB;AAChB,aAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;;AAEA,4DAA2D;;AAE3D;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;;AAEA,iBAAgB;AAChB,aAAY;AACZ;AACA;;;AAGA,+B;;;;;;AClbA;AACA;AACA;AACA,G;;;;;;ACHA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,gCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA,UAAS,yBAAyB;;AAElC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS,yBAAyB;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;;AAE3D,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,4BAA4B;AAC3C;AACA;;;;AAIA;AACA;AACA;AACA;AACA,aAAY,4BAA4B;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc,yBAAyB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAc,4BAA4B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kFAAiF;AACjF;;AAEA;AACA,oCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA,gD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,4B;;;;;;AClZA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB,OAAO;AAC5C;AACA;AACA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa,OAAO;AACpB;AACA,gCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA,UAAS,yBAAyB;;AAElC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS,yBAAyB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;;AAE3D,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,4BAA4B;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,OAAO;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAgB,4BAA4B;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,SAAS;AAC1B;AACA,sBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc,yBAAyB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAc,4BAA4B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kC;;;;;;AClTA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY,wBAAwB;AACpC;AACA,cAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,M;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA,YAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA,+B","file":"mocapjs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 523a35f924ba6ca7bbf7\n **/","BVHCharacter = require('./bvhCharacter.js');\nC3DCharacter = require('./c3dCharacter.js');\nMocapParsers = require('./parsers.js');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/MocapJS.js\n ** module id = 0\n ** module chunks = 0\n **/","var parsers = require('./parsers.js');\n\nvar BVHCharacter = BVHCharacter || {};\n\n\nBVHCharacter = function(n, jm, bm, jg, bg) {\n    this.name = n;\n\n    this.jointMaterial = jm;\n    this.boneMaterial = bm;\n    this.makeJointGeometryFCN = jg;\n    this.makeBoneGeometryFCN = bg;\n\n    this.bvh = [];\n    this.skeleton = new THREE.Group();\n\n    this.skelScale = 1;\n    this.jointMeshes = [];\n    this.boneMeshes = [];\n    this.rootMeshes = [];\n\n    this.originPosition = new THREE.Vector3(0, 0, 0);\n\n    this.ready = false;\n    this.frameTime = 1 / 30;\n    this.frameCount = 0;\n    this.animIndex = 0;\n    this.animStartTimeRef = 0;\n    this.animOffset = 0;\n    this.playing = true;\n\n    this.debug = true;\n    this.useWorker = true;\n\n    this.webSocket = [];\n    this.streamProtocol = \"BVHStream\";\n    this.keepStreamedFrames = true;\n    this.isStreaming = false;\n\n    var self = this;\n\n    //\n\n    this.log = function(m) {\n        if (self.debug)\n            console.log(self.name + \": \" + m.toString());\n    };\n\n    this.loadFromURL = function(url, callback) {\n        self.log(\"Loading the mocap file ...\");\n        //Pace.start();\n        reader = new parsers.bvhParser(this.name + \"READER\");\n        this.url = url;\n        reader.load(url, self.createSkel, self.fillFrames);\n\n        this.callb = callback;\n    };\n\n    this.fillFrames = function() {\n        // self.log(\"Ready!\");\n        self.ready = true;\n        self.playing = true;\n\n        if (self.callb)\n            self.callb();\n    }\n\n    this.createSkel = function(data) {\n        self.bvh = data;\n        self.frameCount = data.frameCount;\n        self.frameTime = data.frameTime;\n\n        self.log(\"Mocap file loaded.\");\n\n        self.log(\"Creating the WebGL Joints.\");\n        self.buildSkelJoints(self.bvh.getSkeleton(), 0);\n\n        self.log(\"Creating the WebGL Bones.\");\n        self.buildSkelBones(self.jointMeshes[0]);\n        \n        self.skeleton.add(self.jointMeshes[0]);\n        self.setSkeletonScale(self.skelScale);\n        self.setSkelUp();\n    };\n\n\n    // Beginning of the Stream Code\n    this.onHeaderReceived = function(data) {\n        self.log(\"Loading the mocap header (skeleton) from the stream...\");\n        headerReader = new parsers.bvhStreamParser();\n        headerReader.readHeader(data, self.createSkel);\n\n        if (self.callb)\n            self.callb();\n\n        Pace.stop();\n    }\n\n    this.onDataChunckReceived = function(rawFrames) {\n        var aa = [];\n\n        for (f = 1; f < rawFrames.length; f++) {\n            var parts = rawFrames[f].trim().split(\" \");\n            for (var j = 0; j < parts.length; j++)\n                parts[j] = +parts[j];\n            aa.push(parts);\n        }\n        diff = self.bvh.fillFrameArray(aa);\n        self.frameCount = self.bvh.frameArray.length;\n\n\n        if (!self.playing) {\n            self.animStartTimeRef = Date.now();\n            //  self.animOffset -= rawFrames.length;\n        }\n        /*\n        // else\n        // self.animOffset = self.animIndex;\n        if (diff > 0)\n        \tself.animOffset -= rawFrames.length + 1;\n        // self.animIndex -= rawFrames.length; //math.max(0,math.min(rawFrames.length, self.bvh.bufferSize));\n        */\n        self.fillFrames();\n        Pace.stop();\n    }\n\n    this.loadFromStream = function(url, callback) {\n        self.log(\"Connecting to the stream server...\");\n        self.isStreaming = true;\n        this.callb = callback;\n        self.webSocket = new WebSocket(url);\n\n        self.webSocket.onerror = function(event) {\n            self.log(\"Error connecting to the stream server \" + event.origin);\n        };\n\n        self.webSocket.onopen = function(event) {\n            self.log(\"Connected to the stream server \" + event.origin);\n            Pace.stop();\n        };\n\n        self.webSocket.onmessage = function(event) {\n            // I'm not doing much of a type and content checking here. Let's just trust the sender for now!\n            // Protocol for header:\n            // $HEADER$\n            // BVH...\n            // Protocl for data chunk with id#:\n            // $FRAMES$id#$\n\n            var messageLines = event.data.split('\\n');\n\n            // self.log(\"Received somthing!\");\n            // self.log(\"The first line is : \" + messageLines[0]);\n\n            if (messageLines.length < 1)\n                return;\n\n            if (messageLines[0] == \"$HEADER$\") {\n                self.onHeaderReceived(event.data);\n\n            } else if (messageLines[0].startsWith(\"$FRAMES$\")) {\n                chunckID = parseInt(messageLines[0].split(\"$\")[2]);\n                self.onDataChunckReceived(messageLines, chunckID);\n            }\n        };\n\n    };\n\n    this.requestFrames = function(i) {\n        self.webSocket.send(\"$GETFRAMES\" + i + \"$\");\n    }\n\n    // End of the Stream Code\n\n    this.setOriginPosition = function(x, y, z) {\n        self.originPosition.set(x, y, z);\n    };\n\n    this.setSkeletonScale = function(s) {\n        self.rootMeshes.forEach(function(c) {\n            c.scale.set(s, s, s);\n        });\n        self.jointMeshes[0].scale.set(s, s, s);\n        self.jointMeshes[0].position.multiplyScalar(s);\n    };\n\n    this.buildSkelJoints = function(joint, parent) {\n        var jointMesh = new THREE.Mesh(self.makeJointGeometryFCN(joint.name, self.skelScale), self.jointMaterial);\n        jointMesh.bvhIndex = joint.jointIndex;\n        jointMesh.offsetVec = new THREE.Vector3(joint.offset[0], joint.offset[1], joint.offset[2]);\n        jointMesh.name = joint.name;\n        jointMesh.jointparent = parent;\n        var a, b, c;\n        if (!joint.isEndSite()) {\n            a = joint.channelNames[joint.channelNames.length - 3][0];\n            b = joint.channelNames[joint.channelNames.length - 2][0];\n            c = joint.channelNames[joint.channelNames.length - 1][0];\n        }\n        jointMesh.rotOrder = a + b + c;\n        self.jointMeshes.push(jointMesh);\n        \n        jointMesh.position.set(jointMesh.offsetVec.x, jointMesh.offsetVec.y, jointMesh.offsetVec.z);\n        \n        var axisHelper = new THREE.AxisHelper( 10 / self.skelScale );\n        jointMesh.add( axisHelper );\n\n\n        joint.children.forEach(function(child) {\n            jointMesh.add(self.buildSkelJoints(child, 1));\n        });\n\n        return jointMesh;\n    };\n\n    this.buildSkelBones = function(rootJointMesh) {\n        rootJointMesh.traverse(function(childJointMesh) {            \n            if (childJointMesh.parent !== null)\n            {\n                if (typeof childJointMesh.bvhIndex === \"undefined\")\n                    return;\n                // move origin (.translate)\n                // rotate\n                // translate (offset + position)\n                h = math.abs(childJointMesh.offsetVec.length());\n                var bgeometry = self.makeBoneGeometryFCN(childJointMesh.parent.name, childJointMesh.name, h, self.skelScale);\n                \n                //BEGIN - Universal      \n                if (childJointMesh.offsetVec.y !== 0)                                               \n                    // bgeometry.translate(0, Math.sign(childJointMesh.offsetVec.y) * h / 2, 0);\n                    bgeometry.translate(0, -h/2, 0);\n                else                                \n                    bgeometry.translate(0, -h / 2,  0);\n                    \n                               \n                dx = Math.atan2(childJointMesh.offsetVec.z,childJointMesh.offsetVec.y);                  \n                dy = Math.atan2(childJointMesh.offsetVec.x,childJointMesh.offsetVec.z);\n                dz = Math.atan2(childJointMesh.offsetVec.x,childJointMesh.offsetVec.y);   \n                 \n                if (self.name == \"Gholi\") {\n                    console.log (childJointMesh.parent.name + \" > \" + childJointMesh.name);\n                    console.log(dx);\n                    console.log(dy);\n                    console.log(dz);\n                    console.log(childJointMesh.offsetVec);\n                }                                      \n\n             \n                // if (childJointMesh.offsetVec.z !== 0) bgeometry.rotateX(math.pi-(dx));\n                // if (childJointMesh.offsetVec.x !== 0) bgeometry.rotateY(math.pi-(dy));\n                // if (childJointMesh.offsetVec.y !== 0) bgeometry.rotateZ(math.pi-(dz));\n\n                bgeometry.rotateX( (math.pi-(dx)));\n                bgeometry.rotateY(-(math.pi-(dy)));\n                bgeometry.rotateZ(-(math.pi-(dz)));\n\n                // bgeometry.rotateX(Math.sign(childJointMesh.offsetVec.z) * math.abs(dx));\n                // bgeometry.rotateY(Math.sign(childJointMesh.offsetVec.x) * math.abs(dy));\n                // bgeometry.rotateZ(Math.sign(childJointMesh.offsetVec.y) * math.abs(dz));\n\n                // bgeometry.rotateX(Math.sign(childJointMesh.offsetVec.x) * math.pi);\n\n                // if ( childJointMesh.offsetVec.x >= 0 ) {                \n                //     bgeometry.rotateX(-dx);                                                                                   \n                // } else {\n                //     bgeometry.rotateX(dx);                                    \n                // }\n\n                // if ( childJointMesh.offsetVec.y >= 0 ) {                \n                //     bgeometry.rotateY(-dy);                                                                                   \n                // } else {\n                //     bgeometry.rotateY(dy);                                    \n                // }\n\n                // if ( childJointMesh.offsetVec.z >= 0 ) {                \n                //     bgeometry.rotateZ(-dz);                                                                                   \n                // } else {\n                //     bgeometry.rotateZ(dz);                                    \n                // }\n                    \n\n                                              \n                //END - Universal\n                \n                var boneMesh = new THREE.Mesh(bgeometry, self.boneMaterial);                \n                \n                boneMesh.joint = childJointMesh.parent;\n                boneMesh.name = childJointMesh.parent.name + \" > \" + childJointMesh.name;\n                \n                childJointMesh.parent.add(boneMesh);                               \n                self.boneMeshes.push(boneMesh);                \n            }\n        });      \n    };\n\n    this.animFrame = function(frame) {\n        var torad = Math.PI / 180;\n        \n        if (frame >= self.frameCount) {\n            self.playing = false;\n            return;\n        }\n        \n\n        this.jointMeshes[0].traverse(function(joint) {\n            \n            if (typeof joint.bvhIndex === \"undefined\") {\n                // var bj = self.bvh.jointArray[joint.parent.bvhIndex];\n                // var offsetVec = joint.parent.offsetVec;\n                // var thisEuler = new THREE.Euler(\n                // (bj.channels[frame][bj.rotationIndex.x] * torad),\n                // (bj.channels[frame][bj.rotationIndex.y] * torad),\n                // (bj.channels[frame][bj.rotationIndex.z] * torad), joint.parent.rotOrder);\n                \n                // joint.localRotMat = new THREE.Matrix4();\n                // joint.localRotMat.makeRotationFromEuler(thisEuler);\n                // joint.rotation.setFromRotationMatrix(joint.localRotMat);            \n                \n                // joint.position.set(offsetVec.x, offsetVec.y, offsetVec.z);\n                return;\n            }\n                \n\n            var bj = self.bvh.jointArray[joint.bvhIndex];\n            var offsetVec = joint.offsetVec;\n            \n            var thisEuler = [];\n\n\n            thisEuler = new THREE.Euler(\n                (bj.channels[frame][bj.rotationIndex.x] * torad),\n                (bj.channels[frame][bj.rotationIndex.y] * torad),\n                (bj.channels[frame][bj.rotationIndex.z] * torad), joint.rotOrder);\n\n\n            joint.localRotMat = new THREE.Matrix4();\n            joint.localRotMat.makeRotationFromEuler(thisEuler);\n            joint.rotation.setFromRotationMatrix(joint.localRotMat);\n\n            if (joint.jointparent !== 0) {\n                // joint.position.set(offsetVec.x, offsetVec.y, offsetVec.z);\n            } else { // root\n                joint.position.set(\n                    bj.channels[frame][bj.positionIndex.x] * self.skelScale + self.originPosition.x,\n                    bj.channels[frame][bj.positionIndex.y] * self.skelScale + self.originPosition.y,\n                    bj.channels[frame][bj.positionIndex.z] * self.skelScale + self.originPosition.z);\n            }\n        });\n\n        // this.rootMeshes.forEach(function(rootMesh) {\n        //     rootMesh.traverse(function(bone, index) {\n        //         var bj = self.bvh.jointArray[bone.joint.bvhIndex];\n\n        //         var offsetVec = new THREE.Vector3(bj.offset[0], bj.offset[1], bj.offset[2]);\n\n        //         bone.rotation.copy(bone.joint.rotation); //setFromRotationMatrix(bone.joint.localRotMat);\n\n        //         if (bone.parent.type === \"Group\") //root\n        //         {\n        //             bone.position.set(bj.channels[frame][bj.positionIndex.x] * self.skelScale + self.originPosition.x,\n        //                 bj.channels[frame][bj.positionIndex.y] * self.skelScale + self.originPosition.y,\n        //                 bj.channels[frame][bj.positionIndex.z] * self.skelScale + self.originPosition.z);\n        //         } else {\n        //             bone.position.set(offsetVec.x,\n        //                 offsetVec.y,\n        //                 offsetVec.z);\n        //         }\n\n        //     });\n        // });\n        // if (self.isStreaming && frame >= self.frameCount - 5 ) {\n        // \tself.animIndex = self.frameCount - 1;\n        // \tself.playing = false;\n\n        // }\n\n        if (self.isStreaming) {\n            self.bvh.consumeFrames(frame);\n            self.frameCount = self.bvh.frameArray.length;\n            // console.log(self.frameCount);\n            if (self.frameCount <= 0)\n                self.playing = false;\n\n            self.animOffset = 0; // self.animOffset - frame;\n            self.animStartTimeRef = Date.now();\n        }\n    };\n\n    this.setSkelUp = function() {\n        this.jointMeshes[0].traverse(function(joint) {\n            if (typeof joint.bvhIndex === \"undefined\")\n                return;\n\n            var bj = self.bvh.jointArray[joint.bvhIndex];\n\n            var offsetVec = joint.offsetVec;\n            var torad = Math.PI / 180;\n            var thisEuler = [];\n\n            thisEuler = new THREE.Euler(0, 0, 0, joint.rotOrder);\n\n            joint.localRotMat = new THREE.Matrix4();\n            joint.localRotMat.makeRotationFromEuler(thisEuler);\n            joint.rotation.setFromRotationMatrix(joint.localRotMat);\n\n            if (joint.jointparent !== 0) {\n                // joint.position.set(offsetVec.x, offsetVec.y, offsetVec.z);\n            } else { // root\n                joint.position.set(self.originPosition.x, self.originPosition.y, self.originPosition.z);\n            }\n        });\n\n        // this.rootMeshes.forEach(function(rootMesh) {\n        //     rootMesh.traverse(function(bone, index) {\n        //         var bj = self.bvh.jointArray[bone.joint.bvhIndex];\n\n        //         var offsetVec = new THREE.Vector3(bj.offset[0], bj.offset[1], bj.offset[2]);\n\n        //         bone.rotation.copy(bone.joint.rotation); //setFromRotationMatrix(bone.joint.localRotMat);\n\n        //         if (bone.parent.type === \"Group\") //root\n        //         {\n        //             bone.position.set(self.originPosition.x, self.originPosition.y, self.originPosition.z);\n        //         } else {\n        //             bone.position.set(offsetVec.x,\n        //                 offsetVec.y,\n        //                 offsetVec.z);\n        //         }\n\n        //     });\n        // });\n    };\n};\n\n\nmodule.exports = BVHCharacter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bvhCharacter.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports ={\n    bvhParser: require('./bvhParser.js'),\n    bvhStreamParser: require('./bvhStreamParser.js')\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/parsers.js\n ** module id = 2\n ** module chunks = 0\n **/","// By Ankit\nvar BVHReader = function () {\n    this.load = function (url, callbackHeader, callbackFrameArray) {\n        $.get(url, function (str) {\n            \n            var dataReturn = parse(str);\n\n            \n            var jointStack = dataReturn[0];\n            var jointMap = dataReturn[1];\n            var jointArray = dataReturn[2];\n            var connectivityMatrix = dataReturn[3]\n            _bvh = new BVHReader.BVH.Skeleton(jointStack[0], jointMap, jointArray, dataReturn[3], dataReturn[4], dataReturn[5], []);\n            \n            if (callbackHeader)\n                callbackHeader(_bvh,'BVH');\n            console.log(\"Blah\");\n            _bvh.fillFrameArray(dataReturn[6]);\n\n            if (callbackFrameArray)\n                   callbackFrameArray();\n\n        });\n    };\n\n    function parse(str) {\n        var lines = str.split('\\n');\n        var jointStack = [];\n        var jointMap = {};\n        var jointArray = [];\n        var connectivityMatrix = [];\n        var frameCount, frameTime, frameArray = [];\n        var i = 0;\n        //parse structure\n        for (i = 1; i < lines.length; i++) {\n            if (!parseLine(lines[i], jointStack, jointMap, jointArray, connectivityMatrix)) {\n                break;\n            }\n        }\n\n        for (i = i + 1; i < lines.length; i++) {\n            var line = lines[i].trim();\n            //when encountering last line\n            if (line === \"\")\n                break;\n            if (line.indexOf(\"Frames\") === 0) {\n                frameCount = +(line.split(/\\b/)[2]);\n            } else if (line.indexOf(\"Frame Time\") === 0) {\n                frameTime = +( line.substr(line.indexOf(\":\") + 1).trim() )\n            } else {\n                var parts = line.split(\" \");\n                for (var j = 0; j < parts.length; j++)\n                    parts[j] = +parts[j];\n                frameArray.push(parts);\n            }\n        }\n\n        //parse motion\n        return [jointStack, jointMap, jointArray, connectivityMatrix, frameCount, frameTime, frameArray];\n    }\n\n    //parses individual line in the bvh file.\n    var parseLine = function (line, jointStack, jointMap, jointArray, connectivityMatrix) {\n        line = line.trim();\n        if (line.indexOf(\"ROOT\") > -1 || line.indexOf(\"JOINT\") > -1 || line.indexOf(\"End\") > -1) {\n            var parts = line.split(\" \");\n            var title = parts[1]; //temporary variable to be used after creating the joint object\n            parts[1] = parts[1] + \"-\" + jointArray.length;\n            var joint = new BVHReader.BVH.Joint(parts[1]);\n            joint.title = title;\n            jointStack.push(joint);\n\n            joint.jointIndex = Object.keys(jointMap).length;\n            jointMap[parts[1]] = joint;\n            jointArray.push(joint);\n            //if the joint is not an end site\n            if( line.indexOf(\"End\") != 0 ){\n                if (jointArray.length == 1) {\n                    joint.channelOffset = 0;\n                } else {\n                    joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n                }\n            }else{\n                //channelLength is 0 for end joints\n                joint.channelLength = 0;\n                joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n            }\n\n        } else if (line.indexOf(\"{\") === 0) {\n\n        } else if (line.indexOf(\"OFFSET\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1][\"offset\"] = parts.slice(1);\n            for(x in jointStack[jointStack.length - 1][\"offset\"]){\n                jointStack[jointStack.length - 1][\"offset\"][x] = +jointStack[jointStack.length - 1][\"offset\"][x]\n            }\n        } else if (line.indexOf(\"CHANNELS\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1].setChannelNames(parts.slice(2));\n            jointStack[jointStack.length - 1][\"channelLength\"] = +parts[1];\n        } else if (line.indexOf(\"}\") === 0) {\n            if (jointStack.length > 1) {\n                child = jointStack.pop();\n                jointStack[jointStack.length - 1].children.push(child);\n                child.parent = jointStack[jointStack.length - 1];\n\n                connectivityMatrix.push([child.parent, child])\n\n                // if(!connectivityMatrix[child.name]){\n                //     connectivityMatrix[child.name] = {}\n                // }\n                // connectivityMatrix[child.name][child.parent.name] = 1;\n\n                // if(!connectivityMatrix[child.parent.name]){\n                //     connectivityMatrix[child.parent.name] = {}\n                // }\n                // connectivityMatrix[child.parent.name][child.name] = 1;\n            }\n        } else if (line.indexOf(\"MOTION\") == 0) {\n            return false;\n        }\n\n        return true;\n    };\n};\n\nBVHReader.BVH = BVHReader.BVH || {};\n\nBVHReader.BVH.Joint = function (name, index) {\n\n    this.name = name;\n    this.children = [];\n    this.isEndSite = function () {\n        return this.children.length == 0;\n    };\n    this.rotationIndex = {};\n    this.positionIndex = {};\n\n    this.getChannels = function () {\n        var allChannels = [];\n        for (i = 0; i < this.skeleton.frameArray.length; i++) {\n            allChannels.push(this.getChannelsAt(i));\n        }\n        return allChannels;\n    };\n    this.getChannelsAt = function (frameNum) {\n        var channelsAtFrame = this.skeleton.frameArray[frameNum];\n        return channelsAtFrame.slice(this.channelOffset, this.channelOffset + this.channelLength);\n    };\n\n    this.setChannelNames = function (nameArr){\n        this.channelNames = nameArr;\n        for(i in this.channelNames){\n            var name = this.channelNames[i];\n            switch(name){\n                case \"Xposition\": this.positionIndex.x = i; break;\n                case \"Yposition\": this.positionIndex.y = i; break;\n                case \"Zposition\": this.positionIndex.z = i; break;\n\n                case \"Xrotation\": this.rotationIndex.x = i; break;\n                case \"Yrotation\": this.rotationIndex.y = i; break;\n                case \"Zrotation\": this.rotationIndex.z = i; break;\n            }\n        }\n    }\n};\n\nBVHReader.BVH.Skeleton = function (root, map, arr, connectivityMatrix, frameCount, frameTime, frameArray) {\n    thisSkeleton = this;\n    this.root = root;\n    this.jointMap = map;\n    this.jointArray = arr;\n    this.connectivityMatrix = connectivityMatrix;\n    this.frameCount = frameCount;\n    this.frameTime = frameTime;\n    this.frameArray = frameArray;\n\n    for (i = 0; i < this.jointArray.length; i++) {\n        this.jointArray[i].skeleton = thisSkeleton;\n    }\n\n\n\n    this.fillFrameArray = function (fa) {\n        this.frameArray = fa;\n        this.frameCount = fa.length;\n            //all the structures are ready. let's calculate the positions\n    for(j=0; j < this.jointArray.length; j++){\n        var joint = this.jointArray[j];\n        updateWithPositions(joint);\n    }\n    }\n\n    this.getChannels = function () {\n        return frameArray;\n    };\n    this.getChannelsAt = function (frameNum) {\n    \t//How do I know which column is what?\n        //Why do you need the column index?\n        return frameArray[frameNum];\n    };\n    this.getFrameRate = function () {\n        return frameCount / frameTime;\n    };\n    this.getSkeleton = function () {\n        return root;\n    };\n\n    this.getHeadJoint = function () {\n    \t// do a quick search in the joint names to see if any of them matches head, else return the something!!!!\n        return jointMap[\"Head\"];\n    };\n    this.getPositionsAt = function (frameNum) {\n    \t//for each joint, calculate its position in XYZ\n        //return an array of joints, each with .x, .y, and .z properties\n    \tposFrame = [];\n\n    \tfor (j=0;j<this.jointArray.length;j++) {\n    \t\tposFrame.push(this.jointArray[j].positions[frameNum]);\n    \t}\n\n    \tposFrame = posFrame.map(function(d) {\n\t\t\treturn {\n\t\t\t\tx : d[0],\n\t\t\t\ty : d[1],\n\t\t\t\tz : d[2],\n\t\t\t};\n\t\t});\n\n        return posFrame;\n    };\n    this.getTPose = function () {\n    \t// This function is basically the same as the getPositionsAt except that all the rotations will be 0\n        console.log(\"Not yet implemented\");\n    };\n\n    function updatePositions(rootOffset, removeRoot, orientation, camera) {\n      //TODO: compelte the specification of this\n\n      for(j=0; j < this.jointArray.length; j++){\n          var joint = this.jointArray[j];\n          updateWithPositions(joint);\n      }\n    }\n\n    function updateWithPositions(joint){\n        var channelNames = joint.channelNames;\n        joint.channels = joint.getChannels();\n        joint.rotations = [];\n        joint.positions = [];\n        joint.rotmat = [];\n        for(i in joint.channels){\n            var channel = joint.channels[i];\n            var xpos = channel[joint.positionIndex.x] || 0,\n            ypos =  channel[joint.positionIndex.y] || 0,\n            zpos =  channel[joint.positionIndex.z] || 0,\n            xangle =  deg2rad(channel[joint.rotationIndex.x] || 0),\n            yangle =  deg2rad(channel[joint.rotationIndex.y] || 0),\n            zangle= deg2rad(channel[joint.rotationIndex.z] || 0);\n\n            // var rotMatrix = math.transpose(getRotationMatrix(xangle, yangle, zangle, \"xyz\"));\n            // var rotMatrix = getRotationMatrix1(xangle, yangle, zangle, \"xyz\"); //this also works\n            var posMatrix = [xpos, ypos, zpos];\n\n            if(joint.parent){\n            \t  posMatrix = [0,0,0];  //At least for the bvhs that we have, this should be set to 0\n\n                // var t = vectorAdd(joint.offset, posMatrix);\n                // var u = matrixMultiply(t, joint.parent.rotations[i]);\n\n                // joint.positions[i] = vectorAdd(u, joint.parent.positions[i]);\n                // joint.rotations[i] = matrixMultiply( rotMatrix, joint.parent.rotations[i]);\n                // joint.rotmat[i] = rotMatrix; \n\n                 if (i==0 && (joint.name ==  \"Spine\" || joint.name == \"L_Femur\")) {\n                    /*console.log(\"head's rot mat: \");\n                    console.log(joint.rotations[i]);\n                    console.log(t);\n                    console.log(u);\n\n                    console.log(\"x: \"+xangle + \"y: \"+yangle + \"z: \"+zangle );\n                    console.log(posMatrix);\n                    */\n                }\n\n            }else{\n                //its the root\n                // joint.rotations[i] = rotMatrix;\n                // joint.rotmat[i] = rotMatrix;\n                joint.positions[i] = posMatrix;//vectorAdd(joint.offset , posMatrix);\n                // ^ we can safely ignore the root's offset\n            }\n        }\n    }\n\n    function deg2rad(deg){\n        return deg * (Math.PI/180);\n    }\n\n\n    function getRotationMatrix(alpha, beta, gamma) {\n\n    //inputs are the intrinsic rotation angles in RADIANTS\n    var ca = Math.cos(alpha),\n    \tsa = Math.sin(alpha),\n\n    \tcb = Math.cos(beta),\n    \tsb = Math.sin(beta),\n\n    \tcg = Math.cos(gamma),\n    \tsg = Math.sin(gamma),\n\n    Rx = [[1, 0, 0], [0, ca, -sa], [0, sa, ca]];\n\n    Ry = [[cb, 0, sb], [0, 1, 0], [-sb, 0, cb]];\n\n    Rz = [[cg, -sg, 0], [sg, cg, 0], [0,    0,   1]];\n\n\n\n\n    var Rzm = math.matrix(Rz);\n    var Rym = math.matrix(Ry);\n    var Rxm = math.matrix(Rx);\n\n    var tt = math.multiply(Rzm, Rym);\n\n    return  math.multiply(tt,Rxm).toArray();\n    //rotationMatrix = math. //Rz*Ry*Rx;\n\n    //     R = Rx*Ry*Rz;\n\t}\n\n    function getRotationMatrix1 (xangle, yangle, zangle, order){\n        var c1 = Math.cos(xangle),\n        c2 = Math.cos(yangle),\n        c3 = Math.cos(zangle),\n        s1 = Math.sin(xangle),\n        s2 = Math.sin(yangle),\n        s3 = Math.sin(zangle);\n\n        if(order === undefined || order.trim() === \"\"){\n            order = \"zxy\";\n        }\n\n        var rotMat = [\n            [1,0,0],\n            [0,1,0],\n            [0,0,1]\n        ];\n\n        switch(order){\n            case \"___zxy\":\n                rotMat = [\n                    [c2*c3-s1*s2*s3, c2*s3+s1*s2*c3, -s2*c1],\n                    [-c1*s3, c1*c3, s1],\n                    [s2*c3+c2*s1*s3, s2*s3-c2*s1*c3, c2*c1]\n                ];\n            break;\n            default:\n              for (o in order){\n                var axis = order[o];\n                var t;\n                switch(axis){\n                    case \"x\":\n                        t = [\n                                [1, 0, 0],\n                                [0,  c1, s1],\n                                [0, -s1, c1],\n                            ]\n                        break;\n                    case \"y\":\n                        t = [\n                                [c2,0,-s2],\n                                [0,1,0],\n                                [s2,0,c2]\n                            ]\n                        break;\n                    case \"z\":\n                        t = [[c3,s3,0],[-s3,c3,0],[0,0,1]]\n                        break;\n                }\n\n                rotMat = matrixMultiply(t, rotMat)\n              }\n          }\n\n        return rotMat;\n    }\n};\n\nfunction vectorAdd(a, b){\n    return math.add(math.matrix(a), math.matrix(b)).toArray();\n}\n\nfunction matrixMultiply(m1, m2) {\n    var a = math.matrix(m1);\n    var b = math.matrix(m2);\n    return math.multiply(a, b).toArray();\n}\n\n\nmodule.exports = BVHReader;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bvhParser.js\n ** module id = 3\n ** module chunks = 0\n **/","// BVH parser by Ankit\n// Stream by Omid\n\n\nvar BVHStreamParser = function () {\n    this.readHeader = function (str, callback) {\n            var dataReturn = parseHeader(str);\n            var jointStack = dataReturn[0];\n            var jointMap = dataReturn[1];\n            var jointArray = dataReturn[2];\n            var connectivityMatrix = dataReturn[3]\n            if (callback)\n                callback(new BVHStreamParser.BVH.Skeleton(jointStack[0], jointMap, jointArray, dataReturn[3], 0, dataReturn[5], dataReturn[6]),'BVH');\n    };\n\n    function parseHeader(str) {\n        var lines = str.split('\\n');\n        var jointStack = [];\n        var jointMap = {};\n        var jointArray = [];\n        var connectivityMatrix = [];\n        var frameCount, frameTime, frameArray = [];\n        var i = 0;\n        //parse structure\n        for (i = 2; i < lines.length; i++) { //  start from 2 to skip the $HEADER$ command\n            if (!parseLine(lines[i], jointStack, jointMap, jointArray, connectivityMatrix)) {\n                break;\n            }\n        }\n\n        for (i = i + 1; i < lines.length; i++) {\n            var line = lines[i].trim();\n            //when encountering last line\n            if (line === \"\")\n                break;\n            if (line.indexOf(\"Frames\") === 0) {\n                frameCount = +(line.split(/\\b/)[2]);\n            } else if (line.indexOf(\"Frame Time\") === 0) {\n                frameTime = +( line.substr(line.indexOf(\":\") + 1).trim() )\n            } else { /// maybe this should be removed\n                var parts = line.split(\" \");\n                for (var j = 0; j < parts.length; j++)\n                    parts[j] = +parts[j];\n                frameArray.push(parts);\n            }\n        }\n\n        //parse motion\n        return [jointStack, jointMap, jointArray, connectivityMatrix, frameCount, frameTime, frameArray];\n    }\n\n    //parses individual line in the bvh file.\n    var parseLine = function (line, jointStack, jointMap, jointArray, connectivityMatrix) {\n        line = line.trim();\n        if (line.indexOf(\"ROOT\") > -1 || line.indexOf(\"JOINT\") > -1 || line.indexOf(\"End\") > -1) {\n            var parts = line.split(\" \");\n            var title = parts[1]; //temporary variable to be used after creating the joint object\n            parts[1] = parts[1] + \"-\" + jointArray.length;\n            var joint = new BVHStreamParser.BVH.Joint(parts[1]);\n            joint.title = title;\n            jointStack.push(joint);\n\n            joint.jointIndex = Object.keys(jointMap).length;\n            jointMap[parts[1]] = joint;\n            jointArray.push(joint);\n            //if the joint is not an end site\n            if( line.indexOf(\"End\") != 0 ){\n                if (jointArray.length == 1) {\n                    joint.channelOffset = 0;\n                } else {\n                    joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n                }\n            }else{\n                //channelLength is 0 for end joints\n                joint.channelLength = 0;\n                joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n            }\n\n        } else if (line.indexOf(\"{\") === 0) {\n\n        } else if (line.indexOf(\"OFFSET\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1][\"offset\"] = parts.slice(1);\n            for(x in jointStack[jointStack.length - 1][\"offset\"]){\n                jointStack[jointStack.length - 1][\"offset\"][x] = +jointStack[jointStack.length - 1][\"offset\"][x]\n            }\n        } else if (line.indexOf(\"CHANNELS\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1].setChannelNames(parts.slice(2));\n            jointStack[jointStack.length - 1][\"channelLength\"] = +parts[1];\n        } else if (line.indexOf(\"}\") === 0) {\n            if (jointStack.length > 1) {\n                child = jointStack.pop();\n                jointStack[jointStack.length - 1].children.push(child);\n                child.parent = jointStack[jointStack.length - 1];\n\n                connectivityMatrix.push([child.parent, child])\n            }\n        } else if (line.indexOf(\"MOTION\") == 0) {\n            return false;\n        }\n\n        return true;\n    };\n};\n\nBVHStreamParser.BVH = BVHStreamParser.BVH || {};\n\nBVHStreamParser.BVH.Joint = function (name, index) {\n\n    this.name = name;\n    this.children = [];\n    this.isEndSite = function () {\n        return this.children.length == 0;\n    };\n    this.rotationIndex = {};\n    this.positionIndex = {};\n\n    this.getChannels = function () {\n        var allChannels = [];\n        for (i = 0; i < this.skeleton.frameArray.length; i++) {\n            allChannels.push(this.getChannelsAt(i));\n        }\n        return allChannels;\n    };\n    this.getChannelsAt = function (frameNum) {\n        var channelsAtFrame = this.skeleton.frameArray[frameNum];\n        return channelsAtFrame.slice(this.channelOffset, this.channelOffset + this.channelLength);\n    };\n\n    this.setChannelNames = function (nameArr){\n        this.channelNames = nameArr;\n        for(i in this.channelNames){\n            var name = this.channelNames[i];\n            switch(name){\n                case \"Xposition\": this.positionIndex.x = i; break;\n                case \"Yposition\": this.positionIndex.y = i; break;\n                case \"Zposition\": this.positionIndex.z = i; break;\n\n                case \"Xrotation\": this.rotationIndex.x = i; break;\n                case \"Yrotation\": this.rotationIndex.y = i; break;\n                case \"Zrotation\": this.rotationIndex.z = i; break;\n            }\n        }\n    }\n};\n\nBVHStreamParser.BVH.Skeleton = function (root, map, arr, connectivityMatrix, frameCount, frameTime, frameArray) {\n    thisSkeleton = this;\n    this.root = root;\n    this.jointMap = map;\n    this.jointArray = arr;\n    this.connectivityMatrix = connectivityMatrix;\n    this.frameCount = frameCount;\n    this.frameTime = frameTime;\n    this.frameArray = frameArray;\n    this.bufferSize = 500;\n\n    for (i = 0; i < this.jointArray.length; i++) {\n        this.jointArray[i].skeleton = thisSkeleton;\n    }\n\n    this.fillFrameArray = function (fa) {\n        this.frameArray.push.apply(this.frameArray,fa);\n        //this.frameArray.push.apply(this.frameArray,fa);\n        \n        diff = this.frameArray.length - this.bufferSize;\n        // console.log('diff = ' + diff);\n        \n        /*\n        if (diff > 0) \n            for (i=0;i<diff;i++)\n                this.frameArray.shift();\n\n        this.frameCount = this.frameArray.length;\n        */\n         \n        if (diff > 0) \n            addedCount = this.frameCount;\n        else\n            addedCount = fa.length;\n\n        for(j=0; j < this.jointArray.length; j++){\n            var joint = this.jointArray[j];\n            updateWithPositionsSinceLast(joint, addedCount);\n        }\n        \n        return diff;\n    }\n\n    this.consumeFrames = function (index) {\n        for (i=0;i<=index;i++) {\n            this.frameArray.shift();\n            for (j=0;j<this.jointArray.length;j++)\n                this.jointArray[j].channels.shift();\n        }\n        this.frameCount = this.frameArray.length;\n    }\n\n    this.getChannels = function () {\n        return frameArray;\n    };\n    this.getChannelsAt = function (frameNum) {\n    \t//How do I know which column is what?\n        //Why do you need the column index?\n        return frameArray[frameNum];\n    };\n    this.getFrameRate = function () {\n        return frameCount / frameTime;\n    };\n    this.getSkeleton = function () {\n        return root;\n    };\n\n    this.getHeadJoint = function () {\n    \t// do a quick search in the joint names to see if any of them matches head, else return the something!!!!\n        return jointMap[\"Head\"];\n    };\n    this.getPositionsAt = function (frameNum) {\n    \t//for each joint, calculate its position in XYZ\n        //return an array of joints, each with .x, .y, and .z properties\n    \tposFrame = [];\n\n    \tfor (j=0;j<this.jointArray.length;j++) {\n    \t\tposFrame.push(this.jointArray[j].positions[frameNum]);\n    \t}\n\n    \tposFrame = posFrame.map(function(d) {\n\t\t\treturn {\n\t\t\t\tx : d[0],\n\t\t\t\ty : d[1],\n\t\t\t\tz : d[2],\n\t\t\t};\n\t\t});\n\n        return posFrame;\n    };\n    this.getTPose = function () {\n    \t// This function is basically the same as the getPositionsAt except that all the rotations will be 0\n        console.log(\"Not yet implemented\");\n    };\n\n    function updatePositions(rootOffset, removeRoot, orientation, camera) {\n      //TODO: compelte the specification of this\n\n      for(j=0; j < this.jointArray.length; j++){\n          var joint = this.jointArray[j];\n          updateWithPositions(joint);\n      }\n    }\n\n    function updateWithPositions(joint){\n        var channelNames = joint.channelNames;\n        joint.channels = joint.getChannels();\n        joint.rotations = [];\n        joint.positions = [];\n        joint.rotmat = [];\n        for(i in joint.channels){\n            var channel = joint.channels[i];\n            var xpos = channel[joint.positionIndex.x] || 0,\n            ypos =  channel[joint.positionIndex.y] || 0,\n            zpos =  channel[joint.positionIndex.z] || 0;\n            // xangle =  deg2rad(channel[joint.rotationIndex.x] || 0),\n            // yangle =  deg2rad(channel[joint.rotationIndex.y] || 0),\n            // zangle= deg2rad(channel[joint.rotationIndex.z] || 0);\n\n            var posMatrix = [xpos, ypos, zpos];\n\n            if(!joint.parent){\n                //its the root\n                joint.positions[i] = posMatrix;//vectorAdd(joint.offset , posMatrix);\n                // ^ we can safely ignore the root's offset\n            }\n        }\n    }\n\n    function updateWithPositionsSinceLast(joint, addedCount){\n        var channelNames = joint.channelNames;\n        joint.channels = joint.getChannels();\n        joint.rotations = [];\n        joint.positions = [];\n        joint.rotmat = [];\n        for(i=joint.channels.length - addedCount;i < joint.channels.length; i++){\n            var channel = joint.channels[i];\n            var xpos = channel[joint.positionIndex.x] || 0,\n            ypos =  channel[joint.positionIndex.y] || 0,\n            zpos =  channel[joint.positionIndex.z] || 0;\n            // xangle =  deg2rad(channel[joint.rotationIndex.x] || 0),\n            // yangle =  deg2rad(channel[joint.rotationIndex.y] || 0),\n            // zangle= deg2rad(channel[joint.rotationIndex.z] || 0);\n\n            var posMatrix = [xpos, ypos, zpos];\n\n            if(!joint.parent){\n                //its the root\n                joint.positions[i] = posMatrix;//vectorAdd(joint.offset , posMatrix);\n                // ^ we can safely ignore the root's offset\n            }\n        }\n    }\n\n    function deg2rad(deg){\n        return deg * (Math.PI/180);\n    }\n};\n\nmodule.exports = BVHStreamParser;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bvhStreamParser.js\n ** module id = 4\n ** module chunks = 0\n **/","var C3DCharacter = C3DCharacter || {};\n\nC3DCharacter = function(n, jm, jg){\n\tthis.name = n;\n\t\n\tthis.markerMaterial = jm;\n\tthis.makeMarkerGeometryFCN = jg;\n\n\tthis.originPosition = new THREE.Vector3(0,0,0);\n\n\tthis.markerdata = [];\n\tthis.ready = false;\n\tthis.scale = 0.1;\n\tthis.markerMeshes = [];\n\n\tthis.frameTime = 1/30;\n\tthis.frameCount = 0;\n\n\tthis.animIndex = 0;\n\tthis.animStartTimeRef = 0;\n\tthis.animOffset = 0;\n\tthis.playing = true;\n\n\tthis.debug = true;\n\n\tvar self = this;\n\n\t//\n\n\tthis.log = function(m) {\n\t\tif (self.debug)\n\t\t\tconsole.log(self.name + \": \"+m.toString());\n\t};\n\n\tthis.loadFromURL = function(url, callback) {\n\t\tself.log(\"Loading the mocap file ...\");\n\t\tPace.start();\n\t\turl2 = \"http://www.sfu.ca/~oalemi/webglplayer/\" + url;\n\t\tself.url = url;\n\t\tPapa.parse(url2, {\n\t\tworker: true,\n\t\tdelimiter: \",\",\t\n\t\tdynamicTyping: true,\n\t\tdownload: true,\n\t\theader: false,\n\t\tcomplete: function(results) {\n\t\t\t//self.markerdata = results.data;\n\n\t\t\tfor (i=0;i<results.data[0].length;i++) {\n\t\t\t\tvar markerMesh = new THREE.Mesh(self.makeMarkerGeometryFCN(results.data[0][i], self.scale), self.markerMaterial);\n\t\t\t\tmarkerMesh.markerIndex = i;\n\t\t\t\tmarkerMesh.name = results.data[0][i];\n\t\t\t\tscene.add(markerMesh);\n\t\t\t\tself.markerMeshes.push(markerMesh);\n\t\t\t}\n\n\t\t\tself.markerNames = results.data[0];\n\t\t\tfor (f=1;f<results.data.length-3;f+=3) {\n\t\t\t\tself.markerdata[(f-1)/3] = [];\n\t\t\t\tfor (m=0;m<self.markerNames.length;m++) {\n\t\t\t\t\tmarker = [];\n\t\t\t\t\tmarker.x = results.data[f][m];\n\t\t\t\t\tmarker.y = results.data[f+1][m];\n\t\t\t\t\tmarker.z = results.data[f+2][m];\n\t\t\t\t\tmarker.name = self.markerNames[m];\n\t\t\t\t\tself.markerdata[(f-1)/3].push(marker);\n\t\t\t\t} \n\t\t\t}\n\t\t\tself.frameCount = self.markerdata.length;\n\t\t\tself.log(\"Done parsing!\");\t\n\t\t\tself.ready = true;\n\t\t\tif (callback)\n\t\t\t\tcallback();\n\t\t}\n\t\t});\n\t};\n\n\tthis.setOriginPosition = function (x, y, z) {\n\t\tself.originPosition.set(x,y,z);\n\t};\n\n\tthis.setSkeletonScale = function(s) {\n\t\tself.rootMeshes.forEach(function (c) {\n\t\t\tc.scale.set(s,s,s);\n\t\t});\n\t\tself.jointMeshes[0].scale.set(s,s,s);\n\t\tself.jointMeshes[0].position.multiplyScalar(s);\n\t};\n\n\n\tthis.animFrame = function (frame) {\n\t\tfor (m=0;m<self.markerMeshes.length; m++) {\n\t\t\tself.markerMeshes[m].position.set(self.markerdata[frame][m].x * self.scale + self.originPosition.x,\n\t\t\t\t\t\t\t\t\t\t \t  self.markerdata[frame][m].y * self.scale + self.originPosition.y,\n\t\t\t\t\t\t\t\t\t\t \t  self.markerdata[frame][m].z * self.scale + self.originPosition.z);\n\t\t}\n\t};\n};\n\nmodule.exports = C3DCharacter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/c3dCharacter.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}